// Code generated by "enumer -json -sql -type Direction,Side,Status,OrderType,OrderKind,LogSource -output enums_helpers.go"; DO NOT EDIT.

package cryptodb

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _DirectionName = "DirectionLongDirectionShort"

var _DirectionIndex = [...]uint8{0, 13, 27}

const _DirectionLowerName = "directionlongdirectionshort"

func (i Direction) String() string {
	if i < 0 || i >= Direction(len(_DirectionIndex)-1) {
		return fmt.Sprintf("Direction(%d)", i)
	}
	return _DirectionName[_DirectionIndex[i]:_DirectionIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _DirectionNoOp() {
	var x [1]struct{}
	_ = x[DirectionLong-(0)]
	_ = x[DirectionShort-(1)]
}

var _DirectionValues = []Direction{DirectionLong, DirectionShort}

var _DirectionNameToValueMap = map[string]Direction{
	_DirectionName[0:13]:       DirectionLong,
	_DirectionLowerName[0:13]:  DirectionLong,
	_DirectionName[13:27]:      DirectionShort,
	_DirectionLowerName[13:27]: DirectionShort,
}

var _DirectionNames = []string{
	_DirectionName[0:13],
	_DirectionName[13:27],
}

// DirectionString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func DirectionString(s string) (Direction, error) {
	if val, ok := _DirectionNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _DirectionNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Direction values", s)
}

// DirectionValues returns all values of the enum
func DirectionValues() []Direction {
	return _DirectionValues
}

// DirectionStrings returns a slice of all String values of the enum
func DirectionStrings() []string {
	strs := make([]string, len(_DirectionNames))
	copy(strs, _DirectionNames)
	return strs
}

// IsADirection returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Direction) IsADirection() bool {
	for _, v := range _DirectionValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Direction
func (i Direction) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Direction
func (i *Direction) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Direction should be a string, got %s", data)
	}

	var err error
	*i, err = DirectionString(s)
	return err
}

func (i Direction) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Direction) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Direction: %[1]T(%[1]v)", value)
	}

	val, err := DirectionString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _SideName = "SideBuySideSell"

var _SideIndex = [...]uint8{0, 7, 15}

const _SideLowerName = "sidebuysidesell"

func (i Side) String() string {
	if i < 0 || i >= Side(len(_SideIndex)-1) {
		return fmt.Sprintf("Side(%d)", i)
	}
	return _SideName[_SideIndex[i]:_SideIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _SideNoOp() {
	var x [1]struct{}
	_ = x[SideBuy-(0)]
	_ = x[SideSell-(1)]
}

var _SideValues = []Side{SideBuy, SideSell}

var _SideNameToValueMap = map[string]Side{
	_SideName[0:7]:       SideBuy,
	_SideLowerName[0:7]:  SideBuy,
	_SideName[7:15]:      SideSell,
	_SideLowerName[7:15]: SideSell,
}

var _SideNames = []string{
	_SideName[0:7],
	_SideName[7:15],
}

// SideString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func SideString(s string) (Side, error) {
	if val, ok := _SideNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _SideNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Side values", s)
}

// SideValues returns all values of the enum
func SideValues() []Side {
	return _SideValues
}

// SideStrings returns a slice of all String values of the enum
func SideStrings() []string {
	strs := make([]string, len(_SideNames))
	copy(strs, _SideNames)
	return strs
}

// IsASide returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Side) IsASide() bool {
	for _, v := range _SideValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Side
func (i Side) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Side
func (i *Side) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Side should be a string, got %s", data)
	}

	var err error
	*i, err = SideString(s)
	return err
}

func (i Side) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Side) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Side: %[1]T(%[1]v)", value)
	}

	val, err := SideString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _StatusName = "StatusPlannedStatusOrderedStatusFilledStatusStoppedStatusClosedStatusCancelledStatusLiquidatedStatusLogged"

var _StatusIndex = [...]uint8{0, 13, 26, 38, 51, 63, 78, 94, 106}

const _StatusLowerName = "statusplannedstatusorderedstatusfilledstatusstoppedstatusclosedstatuscancelledstatusliquidatedstatuslogged"

func (i Status) String() string {
	if i < 0 || i >= Status(len(_StatusIndex)-1) {
		return fmt.Sprintf("Status(%d)", i)
	}
	return _StatusName[_StatusIndex[i]:_StatusIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _StatusNoOp() {
	var x [1]struct{}
	_ = x[StatusPlanned-(0)]
	_ = x[StatusOrdered-(1)]
	_ = x[StatusFilled-(2)]
	_ = x[StatusStopped-(3)]
	_ = x[StatusClosed-(4)]
	_ = x[StatusCancelled-(5)]
	_ = x[StatusLiquidated-(6)]
	_ = x[StatusLogged-(7)]
}

var _StatusValues = []Status{StatusPlanned, StatusOrdered, StatusFilled, StatusStopped, StatusClosed, StatusCancelled, StatusLiquidated, StatusLogged}

var _StatusNameToValueMap = map[string]Status{
	_StatusName[0:13]:        StatusPlanned,
	_StatusLowerName[0:13]:   StatusPlanned,
	_StatusName[13:26]:       StatusOrdered,
	_StatusLowerName[13:26]:  StatusOrdered,
	_StatusName[26:38]:       StatusFilled,
	_StatusLowerName[26:38]:  StatusFilled,
	_StatusName[38:51]:       StatusStopped,
	_StatusLowerName[38:51]:  StatusStopped,
	_StatusName[51:63]:       StatusClosed,
	_StatusLowerName[51:63]:  StatusClosed,
	_StatusName[63:78]:       StatusCancelled,
	_StatusLowerName[63:78]:  StatusCancelled,
	_StatusName[78:94]:       StatusLiquidated,
	_StatusLowerName[78:94]:  StatusLiquidated,
	_StatusName[94:106]:      StatusLogged,
	_StatusLowerName[94:106]: StatusLogged,
}

var _StatusNames = []string{
	_StatusName[0:13],
	_StatusName[13:26],
	_StatusName[26:38],
	_StatusName[38:51],
	_StatusName[51:63],
	_StatusName[63:78],
	_StatusName[78:94],
	_StatusName[94:106],
}

// StatusString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func StatusString(s string) (Status, error) {
	if val, ok := _StatusNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _StatusNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Status values", s)
}

// StatusValues returns all values of the enum
func StatusValues() []Status {
	return _StatusValues
}

// StatusStrings returns a slice of all String values of the enum
func StatusStrings() []string {
	strs := make([]string, len(_StatusNames))
	copy(strs, _StatusNames)
	return strs
}

// IsAStatus returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Status) IsAStatus() bool {
	for _, v := range _StatusValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Status
func (i Status) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Status
func (i *Status) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Status should be a string, got %s", data)
	}

	var err error
	*i, err = StatusString(s)
	return err
}

func (i Status) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Status) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Status: %[1]T(%[1]v)", value)
	}

	val, err := StatusString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _OrderTypeName = "TypeMarketTypeLimit"

var _OrderTypeIndex = [...]uint8{0, 10, 19}

const _OrderTypeLowerName = "typemarkettypelimit"

func (i OrderType) String() string {
	if i < 0 || i >= OrderType(len(_OrderTypeIndex)-1) {
		return fmt.Sprintf("OrderType(%d)", i)
	}
	return _OrderTypeName[_OrderTypeIndex[i]:_OrderTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OrderTypeNoOp() {
	var x [1]struct{}
	_ = x[TypeMarket-(0)]
	_ = x[TypeLimit-(1)]
}

var _OrderTypeValues = []OrderType{TypeMarket, TypeLimit}

var _OrderTypeNameToValueMap = map[string]OrderType{
	_OrderTypeName[0:10]:       TypeMarket,
	_OrderTypeLowerName[0:10]:  TypeMarket,
	_OrderTypeName[10:19]:      TypeLimit,
	_OrderTypeLowerName[10:19]: TypeLimit,
}

var _OrderTypeNames = []string{
	_OrderTypeName[0:10],
	_OrderTypeName[10:19],
}

// OrderTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OrderTypeString(s string) (OrderType, error) {
	if val, ok := _OrderTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OrderTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to OrderType values", s)
}

// OrderTypeValues returns all values of the enum
func OrderTypeValues() []OrderType {
	return _OrderTypeValues
}

// OrderTypeStrings returns a slice of all String values of the enum
func OrderTypeStrings() []string {
	strs := make([]string, len(_OrderTypeNames))
	copy(strs, _OrderTypeNames)
	return strs
}

// IsAOrderType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i OrderType) IsAOrderType() bool {
	for _, v := range _OrderTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for OrderType
func (i OrderType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for OrderType
func (i *OrderType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("OrderType should be a string, got %s", data)
	}

	var err error
	*i, err = OrderTypeString(s)
	return err
}

func (i OrderType) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *OrderType) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of OrderType: %[1]T(%[1]v)", value)
	}

	val, err := OrderTypeString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _OrderKindName = "KindMarketStopLossKindLimitStopLossKindEntryKindTakeProfit"

var _OrderKindIndex = [...]uint8{0, 18, 35, 44, 58}

const _OrderKindLowerName = "kindmarketstoplosskindlimitstoplosskindentrykindtakeprofit"

func (i OrderKind) String() string {
	if i < 0 || i >= OrderKind(len(_OrderKindIndex)-1) {
		return fmt.Sprintf("OrderKind(%d)", i)
	}
	return _OrderKindName[_OrderKindIndex[i]:_OrderKindIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OrderKindNoOp() {
	var x [1]struct{}
	_ = x[KindMarketStopLoss-(0)]
	_ = x[KindLimitStopLoss-(1)]
	_ = x[KindEntry-(2)]
	_ = x[KindTakeProfit-(3)]
}

var _OrderKindValues = []OrderKind{KindMarketStopLoss, KindLimitStopLoss, KindEntry, KindTakeProfit}

var _OrderKindNameToValueMap = map[string]OrderKind{
	_OrderKindName[0:18]:       KindMarketStopLoss,
	_OrderKindLowerName[0:18]:  KindMarketStopLoss,
	_OrderKindName[18:35]:      KindLimitStopLoss,
	_OrderKindLowerName[18:35]: KindLimitStopLoss,
	_OrderKindName[35:44]:      KindEntry,
	_OrderKindLowerName[35:44]: KindEntry,
	_OrderKindName[44:58]:      KindTakeProfit,
	_OrderKindLowerName[44:58]: KindTakeProfit,
}

var _OrderKindNames = []string{
	_OrderKindName[0:18],
	_OrderKindName[18:35],
	_OrderKindName[35:44],
	_OrderKindName[44:58],
}

// OrderKindString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OrderKindString(s string) (OrderKind, error) {
	if val, ok := _OrderKindNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OrderKindNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to OrderKind values", s)
}

// OrderKindValues returns all values of the enum
func OrderKindValues() []OrderKind {
	return _OrderKindValues
}

// OrderKindStrings returns a slice of all String values of the enum
func OrderKindStrings() []string {
	strs := make([]string, len(_OrderKindNames))
	copy(strs, _OrderKindNames)
	return strs
}

// IsAOrderKind returns "true" if the value is listed in the enum definition. "false" otherwise
func (i OrderKind) IsAOrderKind() bool {
	for _, v := range _OrderKindValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for OrderKind
func (i OrderKind) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for OrderKind
func (i *OrderKind) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("OrderKind should be a string, got %s", data)
	}

	var err error
	*i, err = OrderKindString(s)
	return err
}

func (i OrderKind) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *OrderKind) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of OrderKind: %[1]T(%[1]v)", value)
	}

	val, err := OrderKindString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _LogSourceName = "SourceExchangeSourceSoftwareSourceUser"

var _LogSourceIndex = [...]uint8{0, 14, 28, 38}

const _LogSourceLowerName = "sourceexchangesourcesoftwaresourceuser"

func (i LogSource) String() string {
	if i < 0 || i >= LogSource(len(_LogSourceIndex)-1) {
		return fmt.Sprintf("LogSource(%d)", i)
	}
	return _LogSourceName[_LogSourceIndex[i]:_LogSourceIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LogSourceNoOp() {
	var x [1]struct{}
	_ = x[SourceExchange-(0)]
	_ = x[SourceSoftware-(1)]
	_ = x[SourceUser-(2)]
}

var _LogSourceValues = []LogSource{SourceExchange, SourceSoftware, SourceUser}

var _LogSourceNameToValueMap = map[string]LogSource{
	_LogSourceName[0:14]:       SourceExchange,
	_LogSourceLowerName[0:14]:  SourceExchange,
	_LogSourceName[14:28]:      SourceSoftware,
	_LogSourceLowerName[14:28]: SourceSoftware,
	_LogSourceName[28:38]:      SourceUser,
	_LogSourceLowerName[28:38]: SourceUser,
}

var _LogSourceNames = []string{
	_LogSourceName[0:14],
	_LogSourceName[14:28],
	_LogSourceName[28:38],
}

// LogSourceString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LogSourceString(s string) (LogSource, error) {
	if val, ok := _LogSourceNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LogSourceNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LogSource values", s)
}

// LogSourceValues returns all values of the enum
func LogSourceValues() []LogSource {
	return _LogSourceValues
}

// LogSourceStrings returns a slice of all String values of the enum
func LogSourceStrings() []string {
	strs := make([]string, len(_LogSourceNames))
	copy(strs, _LogSourceNames)
	return strs
}

// IsALogSource returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LogSource) IsALogSource() bool {
	for _, v := range _LogSourceValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LogSource
func (i LogSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LogSource
func (i *LogSource) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LogSource should be a string, got %s", data)
	}

	var err error
	*i, err = LogSourceString(s)
	return err
}

func (i LogSource) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *LogSource) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of LogSource: %[1]T(%[1]v)", value)
	}

	val, err := LogSourceString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
