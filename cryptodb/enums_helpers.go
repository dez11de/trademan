// Code generated by "enumer -json -sql -type Side,Status,OrderType,LogSource -output enums_helpers.go"; DO NOT EDIT.

package cryptodb

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

const _SideName = "SideLongSideShort"

var _SideIndex = [...]uint8{0, 8, 17}

const _SideLowerName = "sidelongsideshort"

func (i Side) String() string {
	if i < 0 || i >= Side(len(_SideIndex)-1) {
		return fmt.Sprintf("Side(%d)", i)
	}
	return _SideName[_SideIndex[i]:_SideIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _SideNoOp() {
	var x [1]struct{}
	_ = x[SideLong-(0)]
	_ = x[SideShort-(1)]
}

var _SideValues = []Side{SideLong, SideShort}

var _SideNameToValueMap = map[string]Side{
	_SideName[0:8]:       SideLong,
	_SideLowerName[0:8]:  SideLong,
	_SideName[8:17]:      SideShort,
	_SideLowerName[8:17]: SideShort,
}

var _SideNames = []string{
	_SideName[0:8],
	_SideName[8:17],
}

// SideString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func SideString(s string) (Side, error) {
	if val, ok := _SideNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _SideNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Side values", s)
}

// SideValues returns all values of the enum
func SideValues() []Side {
	return _SideValues
}

// SideStrings returns a slice of all String values of the enum
func SideStrings() []string {
	strs := make([]string, len(_SideNames))
	copy(strs, _SideNames)
	return strs
}

// IsASide returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Side) IsASide() bool {
	for _, v := range _SideValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Side
func (i Side) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Side
func (i *Side) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Side should be a string, got %s", data)
	}

	var err error
	*i, err = SideString(s)
	return err
}

func (i Side) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Side) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Side: %[1]T(%[1]v)", value)
	}

	val, err := SideString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _StatusName = "StatusPlannedStatusOrderedStatusFilledStatusStoppedStatusClosedStatusCancelledStatusLiquidatedStatusLogged"

var _StatusIndex = [...]uint8{0, 13, 26, 38, 51, 63, 78, 94, 106}

const _StatusLowerName = "statusplannedstatusorderedstatusfilledstatusstoppedstatusclosedstatuscancelledstatusliquidatedstatuslogged"

func (i Status) String() string {
	if i < 0 || i >= Status(len(_StatusIndex)-1) {
		return fmt.Sprintf("Status(%d)", i)
	}
	return _StatusName[_StatusIndex[i]:_StatusIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _StatusNoOp() {
	var x [1]struct{}
	_ = x[StatusPlanned-(0)]
	_ = x[StatusOrdered-(1)]
	_ = x[StatusFilled-(2)]
	_ = x[StatusStopped-(3)]
	_ = x[StatusClosed-(4)]
	_ = x[StatusCancelled-(5)]
	_ = x[StatusLiquidated-(6)]
	_ = x[StatusLogged-(7)]
}

var _StatusValues = []Status{StatusPlanned, StatusOrdered, StatusFilled, StatusStopped, StatusClosed, StatusCancelled, StatusLiquidated, StatusLogged}

var _StatusNameToValueMap = map[string]Status{
	_StatusName[0:13]:        StatusPlanned,
	_StatusLowerName[0:13]:   StatusPlanned,
	_StatusName[13:26]:       StatusOrdered,
	_StatusLowerName[13:26]:  StatusOrdered,
	_StatusName[26:38]:       StatusFilled,
	_StatusLowerName[26:38]:  StatusFilled,
	_StatusName[38:51]:       StatusStopped,
	_StatusLowerName[38:51]:  StatusStopped,
	_StatusName[51:63]:       StatusClosed,
	_StatusLowerName[51:63]:  StatusClosed,
	_StatusName[63:78]:       StatusCancelled,
	_StatusLowerName[63:78]:  StatusCancelled,
	_StatusName[78:94]:       StatusLiquidated,
	_StatusLowerName[78:94]:  StatusLiquidated,
	_StatusName[94:106]:      StatusLogged,
	_StatusLowerName[94:106]: StatusLogged,
}

var _StatusNames = []string{
	_StatusName[0:13],
	_StatusName[13:26],
	_StatusName[26:38],
	_StatusName[38:51],
	_StatusName[51:63],
	_StatusName[63:78],
	_StatusName[78:94],
	_StatusName[94:106],
}

// StatusString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func StatusString(s string) (Status, error) {
	if val, ok := _StatusNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _StatusNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to Status values", s)
}

// StatusValues returns all values of the enum
func StatusValues() []Status {
	return _StatusValues
}

// StatusStrings returns a slice of all String values of the enum
func StatusStrings() []string {
	strs := make([]string, len(_StatusNames))
	copy(strs, _StatusNames)
	return strs
}

// IsAStatus returns "true" if the value is listed in the enum definition. "false" otherwise
func (i Status) IsAStatus() bool {
	for _, v := range _StatusValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for Status
func (i Status) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Status
func (i *Status) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("Status should be a string, got %s", data)
	}

	var err error
	*i, err = StatusString(s)
	return err
}

func (i Status) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *Status) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Status: %[1]T(%[1]v)", value)
	}

	val, err := StatusString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _OrderTypeName = "TypeHardStopLossTypeSoftStopLossTypeEntryTypeTakeProfit"

var _OrderTypeIndex = [...]uint8{0, 16, 32, 41, 55}

const _OrderTypeLowerName = "typehardstoplosstypesoftstoplosstypeentrytypetakeprofit"

func (i OrderType) String() string {
	if i < 0 || i >= OrderType(len(_OrderTypeIndex)-1) {
		return fmt.Sprintf("OrderType(%d)", i)
	}
	return _OrderTypeName[_OrderTypeIndex[i]:_OrderTypeIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _OrderTypeNoOp() {
	var x [1]struct{}
	_ = x[TypeHardStopLoss-(0)]
	_ = x[TypeSoftStopLoss-(1)]
	_ = x[TypeEntry-(2)]
	_ = x[TypeTakeProfit-(3)]
}

var _OrderTypeValues = []OrderType{TypeHardStopLoss, TypeSoftStopLoss, TypeEntry, TypeTakeProfit}

var _OrderTypeNameToValueMap = map[string]OrderType{
	_OrderTypeName[0:16]:       TypeHardStopLoss,
	_OrderTypeLowerName[0:16]:  TypeHardStopLoss,
	_OrderTypeName[16:32]:      TypeSoftStopLoss,
	_OrderTypeLowerName[16:32]: TypeSoftStopLoss,
	_OrderTypeName[32:41]:      TypeEntry,
	_OrderTypeLowerName[32:41]: TypeEntry,
	_OrderTypeName[41:55]:      TypeTakeProfit,
	_OrderTypeLowerName[41:55]: TypeTakeProfit,
}

var _OrderTypeNames = []string{
	_OrderTypeName[0:16],
	_OrderTypeName[16:32],
	_OrderTypeName[32:41],
	_OrderTypeName[41:55],
}

// OrderTypeString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func OrderTypeString(s string) (OrderType, error) {
	if val, ok := _OrderTypeNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _OrderTypeNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to OrderType values", s)
}

// OrderTypeValues returns all values of the enum
func OrderTypeValues() []OrderType {
	return _OrderTypeValues
}

// OrderTypeStrings returns a slice of all String values of the enum
func OrderTypeStrings() []string {
	strs := make([]string, len(_OrderTypeNames))
	copy(strs, _OrderTypeNames)
	return strs
}

// IsAOrderType returns "true" if the value is listed in the enum definition. "false" otherwise
func (i OrderType) IsAOrderType() bool {
	for _, v := range _OrderTypeValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for OrderType
func (i OrderType) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for OrderType
func (i *OrderType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("OrderType should be a string, got %s", data)
	}

	var err error
	*i, err = OrderTypeString(s)
	return err
}

func (i OrderType) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *OrderType) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of OrderType: %[1]T(%[1]v)", value)
	}

	val, err := OrderTypeString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}

const _LogSourceName = "SourceTriggerSourceSoftwareSourceUser"

var _LogSourceIndex = [...]uint8{0, 13, 27, 37}

const _LogSourceLowerName = "sourcetriggersourcesoftwaresourceuser"

func (i LogSource) String() string {
	if i < 0 || i >= LogSource(len(_LogSourceIndex)-1) {
		return fmt.Sprintf("LogSource(%d)", i)
	}
	return _LogSourceName[_LogSourceIndex[i]:_LogSourceIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _LogSourceNoOp() {
	var x [1]struct{}
	_ = x[SourceTrigger-(0)]
	_ = x[SourceSoftware-(1)]
	_ = x[SourceUser-(2)]
}

var _LogSourceValues = []LogSource{SourceTrigger, SourceSoftware, SourceUser}

var _LogSourceNameToValueMap = map[string]LogSource{
	_LogSourceName[0:13]:       SourceTrigger,
	_LogSourceLowerName[0:13]:  SourceTrigger,
	_LogSourceName[13:27]:      SourceSoftware,
	_LogSourceLowerName[13:27]: SourceSoftware,
	_LogSourceName[27:37]:      SourceUser,
	_LogSourceLowerName[27:37]: SourceUser,
}

var _LogSourceNames = []string{
	_LogSourceName[0:13],
	_LogSourceName[13:27],
	_LogSourceName[27:37],
}

// LogSourceString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func LogSourceString(s string) (LogSource, error) {
	if val, ok := _LogSourceNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _LogSourceNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to LogSource values", s)
}

// LogSourceValues returns all values of the enum
func LogSourceValues() []LogSource {
	return _LogSourceValues
}

// LogSourceStrings returns a slice of all String values of the enum
func LogSourceStrings() []string {
	strs := make([]string, len(_LogSourceNames))
	copy(strs, _LogSourceNames)
	return strs
}

// IsALogSource returns "true" if the value is listed in the enum definition. "false" otherwise
func (i LogSource) IsALogSource() bool {
	for _, v := range _LogSourceValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for LogSource
func (i LogSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for LogSource
func (i *LogSource) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("LogSource should be a string, got %s", data)
	}

	var err error
	*i, err = LogSourceString(s)
	return err
}

func (i LogSource) Value() (driver.Value, error) {
	return i.String(), nil
}

func (i *LogSource) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of LogSource: %[1]T(%[1]v)", value)
	}

	val, err := LogSourceString(str)
	if err != nil {
		return err
	}

	*i = val
	return nil
}
